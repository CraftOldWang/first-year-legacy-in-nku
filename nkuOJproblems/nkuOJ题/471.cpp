//#include<iostream>
//using namespace std;
// 
////35min
//// 前面想投机取巧，不处理数字，直接在h跟h+1这两个小时数内解决战斗
//// 后来发现漏了情况，分钟数是不能超过60的，本来想再修修补补，发现复杂度太大
//// 果断选择换方向。（已经花了比较久时间）
//// 然后发现本质是在输出十位和个位，所以用h / 10 和 h % 10。
//// 然后按新方法分类了，这个分类是全的，应当ok
//// 然后我把一个%取模运算符写成&按位与了（手误）
//// 又改错，这回终于过了
//// 
////
//
//int main()
//{
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++)
//	{
//		char a[6];
//		cin >> a;
//		int h, m;
//		h = (a[0] - '0') * 10 + (a[1] - '0');
//		m= (a[3] - '0') * 10 + (a[4] - '0');
//		int vh, vm;
//		//这里不用这么麻烦，用整除和取余数可以搞
//		//这个技巧之前在逆转一个整数这种题目中用过
//		vh = (a[1] - '0') * 10 + (a[0] - '0');
//		vm = (a[4] - '0') * 10 + (a[3] - '0');
//
//		//在本小时内
//		if (vh < 60 && m < vh)
//		{
//			cout << h / 10 << h % 10 << ':' << vh / 10 << vh % 10;
//			if(i!=n)
//			{
//				cout<< endl;
//			}
//			
//		}
//		//小时开始+1，但是增到24点
//		else if(h+1==24)
//		{
//			cout << "00:00" ;
//			if (i != n)
//			{
//				cout << endl;
//			}
//		}
//		//小时+1不是24点，由于在23点必有，所以小时数不管多小都可以放心往上加
//		else
//		{
//			while (1)
//			{
//				h++;
//				vh = (h % 10) * 10 + h / 10;
//				if (vh < 60)
//				{
//					cout << h / 10 << h % 10 << ':' << vh / 10 << vh % 10;
//					if (i != n)
//					{
//						cout << endl;
//					}
//					break;
//				}
//				
//
//			}
//		}
//
//		
//		
//	}
//	
//
//	return 0;
//}
//
//
///*if (m < vh)
//		{
//			cout << a[0]<<a[1] << ':' << a[1]<<a[0] << endl;
//		}
//		else
//		{
//			if (h == 23)
//			{
//				cout << "00:00" << endl;
//			}
//			else
//			{
//				if (a[1] == 9)
//				{
//					cout << char(a[0] + 1) << 0 << ':' << 0 << char(a[0] + 1);
//				}
//				else
//				{
//					cout << a[0]<<char(a[1]+1) << ':' << char(a[1] + 1) << a[0] << endl;
//				}
//
//			}
//		}*/